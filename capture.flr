// Tutorial: Capturing Real World Knowledge in Ergo/Flora
// https://sites.google.com/a/coherentknowledge.com/tutorial-capturing-real-world-knowledge/home

// @!{rule_id}
// ?Variable переменная  ?_Var переменная для которой не важно ее значение
// blablabla :- bebebe	blablabla при условии что, такая что bebebe
// -> имеет значение, is-a, isa
// => имеет тип результата, отображает в тип, ex: fn_main => int
// A:B	 A имеет тип B, ex: main:function => int
// A::B  А подкласс B, A вид B, a kind of, ako


// root class: Thing					// вещь

Event :: Thing.							// событие a kind of вещи
Entity :: Thing.						// сущность ako вещь

{DrivingSituation,Action} :: Event.		// ситуация вождения, действие: события
DrivingEntity :: Entity.				// сущность управления
SpatialEntity :: Entity.				// пространственная сущность

Drive :: Action.						// управление ako действие
IllegalDrive :: Drive.					// неправильное управление

// property: agent
// domain: Action
// value range: Entity
Action[| agent => Entity |].			// agent function maps action => entity

Event [|
	participant => Entity,				// участник события
	follows => Event					// связь событий, следует за...
|].

DrivingSituation[|						// в случае ситуации управления
	rightOfWay => DrivingEntity|].		// приоритет задан для участника движения

// функциональное определение неправильного вождения:
// если сущности {E1,E1}:Entity участвуют
// в ситуации вождения S->DrivingSituation в которой E2 имеет приоритет
// но E1 движется первым, то движение E1 нарушает правила

@!{illegal_drive}		// rule id
?D:IllegalDrive :-		// var D типа IllegalDrive такая что:-
	// движение D агента-сущности E1, следущем за ситуацией управления S
	?D:Drive[agent->?E1:Entity, follows->?S:DrivingSituation],
	// в ситуации когда из участников E1,E2 приоритет имеет E2
	?S[participant -> {?E1,?E2}, rightOfWay -> ?E2:Entity],
	// c запретом сингулярности когда E1,E2 одна и та же сущность
	?E1 != ?E2
.

// test illegal_drive, mock up actors/situation
P1 : DrivingEntity.
P2 : DrivingEntity.
D1 : Drive [agent -> P1, follows -> S1].
S1 : DrivingSituation [participant -> {P1,P2}, rightOfWay -> P2].
// assert query: D1:IllegalDrive
// or search illegal drivers by query
?- ?IllegalDriver:IllegalDrive.



